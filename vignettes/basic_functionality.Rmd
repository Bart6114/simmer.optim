---
title: "Basic Functionality"
author: "Bart Smeets, Iñaki Ucar"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic Functionality}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# DES & parameter optimization

Discrete-event simulation (DES) is often used to analyze processes. Using DES one could for example give an answer to the question 'if we have `x` amount of resources of type `A`, what will the average waiting time in the process be. One way of going about this is to manually adjust the value of `x` and rerun the simulation at each change and evaluate the results. Another approach is to use a parameter optimization method.

In parameter optimization we work with the following key aspects:

- objective: a variable in simulated process that we want to minimize or maximize
- constraints: upper and lower boundaries on variables in the simulation
- inputs: the simulation parameters that we want to manipulate in order to achieve a minimization / maximization of the objective

# A basic example

See the basic `simmer` example below.

```{r}
library(simmer)
library(dplyr)

t0<-create_trajectory() %>%
  seize("nurse") %>%
  timeout(function() rpois(1, 10)) %>%
  release("nurse") %>%
  seize("cardiologist") %>%
  timeout(function() rpois(1, 20)) %>%
  release("cardiologist")

env<-simmer() %>%
  add_generator("patient", t0, at(seq(0,60*4, 15))) %>%
  add_resource("nurse", 1) %>%
  add_resource("cardiologist", 1) %>%
  run()
```

In this example, a patient first sees a nurse, followed by a visit to the cadiologist. The consultation is planned to last 4 hours (or 240 minutes).

In the plot below, we can see that the process isn't very stable. Moreover it lasts a good bit more than 4 hours.

```{r}
plot_evolution_arrival_times(env, "waiting_time")
```

The number of patients served in this process is:

```{r}
get_mon_arrivals(env) %>% NROW()
```

While the number of patients served before the planned end of the consultation (after 4 hours) is:

```{r}
get_mon_arrivals(env) %>%
  filter(end_time < 4*60) %>%
  NROW()
```


## Optimizing the situation

The hospital wants to reorganize the process. The process requirements are specified as follows:

- a maximization of the number of patients served before the 4 hour mark has been reached (= **objective**)
- a employee budget of 1500€ is available for the consultation (= **constraint**)
  - rate nurse: 50€ / hr
  - rate cardiologist: 100€ / hr
- a maximum average waiting time of 30 minutes is allowed (= **constraint**)


To optimize the scenario we are going to check a number of different values for the following variables.

- the resource capacity: a range of `1:4` for each resource
- the inter-arrival time: a vector of `c(10, 15, 20, 25)`

For this small problem, testing all the possiblities by hand will become somewhat labourious:

```{r}
expand.grid(nurse = 1:4,
            cardiologist = 1:4,
            IAT = c(10, 15, 20, 25)) %>% NROW()

```

In other words, we would have to test 64 possible combinations of these variables.


## Modeling the problem

## The result

Let's plug these variables into the simulation and see what we get.

# Available optimizers

## Grid optimization

The grid optimization algorithm starts by building a grid with all the possible combination of the values you supply to it. To illustrate this, consider the below example where we generate all possibile combinations of `x` and `y` for when we pass a range of `1:2` to both the values.

```{r}
expand.grid(
  x=1:2,
  y=1:2
)
```


## Simulated annealing

## Differential evolution
